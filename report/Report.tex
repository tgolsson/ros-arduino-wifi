
\documentclass[11pt]{article}

\include{preamble}
\bibliographystyle{ieeetr}
%% For make-title
\title{Laboration 3: Differential Drive with WiFi control\\ {\small Sensors and Sensing}} \author{Benny Frost, Tom Olsson}
\date{\today}

\begin{document}
\maketitle %Title area
\begin{center}
  \emph{All code for this exercise can be found at \\ \url{https://github.com/tgolsson/ros-arduino-wifi}}
\end{center}
\tableofcontents
\lstlistoflistings % List of all code snippets
\listoffigures % List of all figures
\listoftables \lstset{
  matchrangestart=t} %initialise the linerange-macro for \lstinput...


\section{Motivation and theory}
The goal of this project was to implement a differential drive robot based on the Robot Operation System [ROS] on Arduino, which can be controlled using a WiFi connection. While a differential drive is easy to implement and test using a wired connection, most realistic scenarios will require wireless operation. As ROS is very common in the scientific community, and Arduino is a cheap prototyping platform in comparison to prebuilt robots, this could allow a much larger freedom in robot design. \par

The goals are:
\begin{itemize}
\item[$\Rightarrow$] To construct a robot with two powered wheels
\item[$\Rightarrow$] Setup the two motors with a differential drive controller
\item[$\Rightarrow$] Implement WiFi communication between PC and Arduino 
\item[$\Rightarrow$] Tune the odometry
\end{itemize}

\subsection{PID with feedback}
PID in the name PID-controller is short for \emph{Proportional}-\emph{Integral}-\emph{Derivative}-controller. As this implies, the controlling signal is based on a proportion of the current error, the previous error, and the rate of change of the observed error. Sometimes, the error is augmented to include a part of the previous output value. In the case of velocity control it can be used to counteract overshoot if the observable value does not react instantly to output value. The mathemathical formulation of this is shown in \ref{eq:et}-\vref*{eq:pid}.\par \vspace{10pt}
{\footnotesize
  \begin{tabular}{l l l}
    \textbf{Let:} \\
 &$e(t)$ &be some error measurement between current state x(t) and preferred state r(t)\\
 &$\di{K}{p}$, $\di{K}{i}$, $\di{K}{d}$ &be the respective weights for the proportional, integral and derivate terms \\
 &$u(t)$ &be the output signal at time \emph{t} \\
    \textbf{Then:}
  \end{tabular}
  \begin{align}
    e(t) &= r(t) - x(t) - u(t-1)\label{eq:et}\\
    u(t) &= \di{K}{p}\cdot e(t) + \di{K}{i} \cdot\int_{0}^{t}e(\tau)\cdot \dif\tau + \di{K}{d} \cdot \od{e(t)}{t}\label{eq:pid}
  \end{align}}
\par

This formulation of the PID controller borrows from feed-forward open-loop control by partially ignoring the current measurements\footnote{An open loop controller has no sensory information: it has only state and model.}. The controller is shown in fig. \vref{fig:pid}. \par
\begin{figure}[htb]
  \centering
\begin{tikzpicture}[auto, node distance=2cm,>=latex']
  \node [input, name=rinput] (rinput) {};
  \node [sum, right of=rinput, node distance=2cm] (sum1) {$\sum$};
  \node [input, name=input2, above of=sum1] (input2) {};
  \node [block, right of=sum1, node distance=4cm] (ki) {$k_{i} * \int_0^t e(t) $};
  \node [block, above of=ki,node distance=1.5cm] (kp){$k_p\cdot e(t)$};
  \node [block, below of=ki,node distance=1.5cm] (kd) {$k_d * \frac{e(t)}{\dif t}$};
  \node [sum, right of=ki,node distance=3cm] (sum2) {$\sum$};
  \node [output, right of=sum2, node distance=2cm] (output) {};
  \node [tmp, below of=kd,node distance=1cm] (tmp1){$u(t-1)$};
  \draw [->] (rinput) -- node{$r(t)$} (sum1);
  \draw [->] (input2) -- node{$x(t)$} (sum1);
  \draw [->] (sum1.east) -- node[midway,stacked,name=cen]{$e(t)$}  (ki.west);
  \draw [->] (cen) |- (kp.west);
  \draw [->] (cen) |- (kd.west);
  \draw [->] (ki.east) -- (sum2.west);
  \draw [->] (kp.east) -| (sum2.north);
  \draw [->] (kd.east) -| (sum2.south);
  \draw [->] (sum2) -- node[name=z]{$u(t)$} (output);
  \draw[->] (z) |- (tmp1);
  \draw[->] (tmp1) -| (sum1);
\end{tikzpicture}
\caption[PID controller with feedback]{PID controller with feedback term.}
\label{fig:pid}
\end{figure}\par
Another modification of PID controllers to improve motor control is the addition of an output deadband or \emph{stiction}\footnote{A portmanteau of \emph{static friction}}. Stiction is the static cohesion threshold that needs to be overcome in order to bring an object from rest when in contact with other objects. In the case of a motor, this can be seen as the minimum \texttt{PWM}-value where the shaft starts turning consistently.
\subsection{Communication rates}
\label{subsec:cr}
As the \texttt{Arduino ros\_lib} implementation is based on the premise of serial communication, some things need to be taken into consideration. No matter whether operating over the USB port or a direct \texttt{TX,RX} connection a serial protocol is always synced, and has a more or less constant rate of information, and has predictable packet sizes. \par

TCP/IP on the other hand - which is the wireless protocol for a sustained server/client connection - is not synced, nor does it make any guarantee on any communication speeds. The only guarantee is that the data will arrive at some point, and that it will be possible to retrieve the packages in proper order. Compared to serial it also makes no guarantee on packet size; and may sometimes try to limit the number of packages sent by collating many small packets into larger ones using f.ex. Nagle's algorithm. \par

This discrepancy means that one cannot rely on data arriving regularly, and must make sure that the implementation can handle the problems that can occur. These problems could be a message being broken up into multiple parts, or only recieving half the message, a connection dropout, etc.
% The communication and protocol differences between Serial and WiFi
\subsection{Differential Drive}
A differential drive is a kinematic model for two individually controlled wheels used to control both speed and rotation by altering the relative speed between the wheels. The controller implemented here is an inverse kinematic model; i.e., the desired output is given and then the kinematic model is based to give these output parameters. \par
{\footnotesize
  \begin{tabular}{l l l}
    \textbf{Let:} \\
 &$v, \omega$ & be the desired linear (\emph{m/s}) and angular velocities (\emph{rad/s})\\
 &$L$ &be the distance between the two wheels \\
 &$r$ &be the radius of the robots wheels \\
 &$k$ &be the number of encoder ticks per shaft rotation\\
    &$u_l, u_r$ &be the left and right encoder speeds \\
    \textbf{Then:}
  \end{tabular}
  \begin{align}
    u_l &=  \frac{2\pi r}{k} \cdot \begin{cases}
                    \hspace{5pt}\left(\frac{v}{\omega} - L \right) * \omega \hspace{5pt} & if \omega \neq 0\\
                    \hspace{5pt} v & otherwise
                  \end{cases} \vspace{5pt} \\
    u_r &=  \frac{2\pi r}{k} \cdot \begin{cases}
                    \hspace{5pt}\left(\frac{v}{\omega} + L \right) * \omega \hspace{5pt} & if \omega \neq 0\\
                    \hspace{5pt}v & otherwise
                  \end{cases} 
  \end{align}}

\subsection{Odometry}
The kinematic model for differential drives can be used to estimate the robots current position relative to the starting position. The equations for updating the robots position are shown in eq. \ref{eq:position1}-\vref*{eq:position2}. \par
{\footnotesize
  \begin{tabular}{l l l}
    \textbf{Let:} \\
 &$L$ &be the distance between the two wheels \\
 &$r$ &be the radius of the robots wheels \\
 &$k$ &be the number of encoder ticks per shaft rotation\\
 &$\hat{u}_l, \hat{u}_r$ &be the smoothed left and right measured encoder speeds (\emph{ticks/second})\\
&$x$, $y$, $\theta$ &be the position and rotation of the robot in a 2D coordinate system\\
    \textbf{Then:}
  \end{tabular}
  \begin{align}
    l_{left} &= \frac{2\pi r}{k} \cdot \hat{u}_l\label{eq:position1}\\
    l_{right} &= \frac{2\pi r}{k} \cdot \hat{u}_r\\
    \Delta &= \frac{(l_{right} - l_{left})}{L}\\
    d &= \frac{l_{right} + l_{left}}{2}\\
    \Delta_x &= \begin{cases}
                    \hspace{5pt}d \cdot \cos\left(\frac{\Delta}{2}\right) & if \left|\Delta\right| < \epsilon\\
                    \hspace{5pt}\frac{d}{\Delta} \cdot \sin\left(\Delta\right) & otherwise
                  \end{cases} \vspace{5pt}  \\
    \Delta_y &= \begin{cases}
                    \hspace{5pt}d \cdot \sin\left(\frac{\Delta}{2}\right) & if \left|\Delta\right| < \epsilon\\
                    \hspace{5pt}\frac{d}{\Delta} \cdot \left(1-\cos\left(\Delta\right)\right) & otherwise
                  \end{cases} \vspace{5pt}\\
    x_t &= x_{t-1} + \Delta_x \cdot \cos\left(\theta_{t-1}\right) - \Delta_y \cdot \sin\left(\theta_{t-1}\right)\\
    y_t &= y_{t-1} + \Delta_y \cdot \sin\left(\theta_{t-1}\right) + \Delta_y \cdot \cos\left(\theta_{t-1}\right)\\
    \theta_t &= \theta_{t-1} + \Delta\hspace{10pt}\label{eq:position2}
  \end{align}}

\section{Implementation}
The purpose of this project is to build a robot with two drive wheels. This robot shall use an Arduino Due controller board with a differential drive controller for these wheels, and communicate to a master node using WiFi and TCP/IP. Part of the project is also measuring and tuning the accuracy for the robots odometry.\par


\subsection{Hardware and environment}
The project used an \emph{Arduino Due} microcontroller \cite{arduinodue}, with the \emph{Arduino Motor Shield R3} \cite{motorshield}. These are programmed using Serial-over-USB; with the dedicated IDE. The version of the IDE used is 1.6.5. The project also includes usage of the \emph{Robot Operating System} [ROS], version \emph{Indigo Igloo}. Two WiFi modules were tested during the project, the official \emph{WiFi Shield  R3} \cite{wifishield} as well as the \emph{ESP8266} \cite{ESP8266}. \par

  The motors used are the \emph{Micro Motors RHE158 75:1 12V DC} \cite{motors}.

% Hardware + Softwares used
\subsection{Physical design}
The main body of the robot is built from aluminum plating and profiles to get a robust robot. The circuit boards are attached to Plexiglas which then are attached to the main body. This is done to get a good insulation from the main body. The Plexiglas pieces are attached with Velcro so it will be easy to detach them if necessary. At front the two motors with the driving wheels was mounted and two passive wheels where mounted at the back of the robot. The passive wheels do not swivel and there was a concern if this would work. Testing showed that the two electrical motors  were too weak to be able to turn the robot with this setup. This is probably because the friction against the floor is too high. A centered swivel wheel was therefore mounted at the rear of the robot. The robot is shown in fig. \vref{fig:robot}. \par

\begin{figure}[ht]
  \centering
  \includegraphics[width=.6\textwidth]{figures/robot.jpg}
  \caption{\label{fig:robot} The robot. The centered swivel wheel is at the back of the robot. Motor battery pack not mounted for better viewing.}
\end{figure}


For controlling the robot, an Arduino Due microcontroller is used with an Arduino Motorshield, and for communication an Arduino WiFi shield is used. These two shields are made to sit on top of the Arduino Due. However, this means that the WiFi shield and Motor shield will also sit on top of each other. Since the WiFi shield and the Motor shield use the same I/O pins of the Arduino Due it was decided that only the WiFi shield should be mounted on top of the Arduino Due and the Motor shield should be mounted next to the main board and be connected to the Arduino Due with wires, and by doing this I/O pins could be rerouted to be used for the Motor shield. Fig. \vref{fig:wiring} shows how the Arduino Due, Arduino Motor shield and ESP8266 are connected. \par

\begin{figure}[ht]
  \centering
  \includegraphics[width=.75\textwidth]{figures/wiring.jpg}
  \caption{\label{fig:wiring} The wiring diagram for the robot's electronics}
\end{figure}

\subsection{WiFi communication}
During setup and configuration of the Arduino WiFi shield it was obvious that the communication was very slow, taking almost two seconds from sending data to reaching the destination, which was documented by others online \cite{wificard1,wificard2}. Similarly, it was discovered that the largest package that could be sent to the Arduino WiFi card is 92 bytes. If the package is larger there will be a silent failure. With all this it was decided to use another WiFi card. We decided to use a very popular WiFi card, ESP8266. \par

The ESP8266 is a standalone microcontroller with built-in WiFi support \cite{ESP8266}. This card is often recommended instead of the official WiFi card both because of its cost as well as superior performance, which is the reason we use it. Similarly to the normal arduino boards it comes with its own toolchain, and therefore runs the code on its own in a separate process from the main Arduino  board. This allows the card to be setup to handle I/O asynchronously from the main control loop which is a big performance gain. The final communication setup is shown in fig. \vref{tikz:communicationschema}.\par

	\begin{figure}[h]
		\resizebox{1\linewidth}{!}{
			\begin{tikzpicture}[node distance=2cm]
				\begin{pgfonlayer}{main}
				\node (pc) [startstop] {PC (roscore)};
				\node (serial) [process, below of=pc,yshift=-0.5cm, text width=4cm] {WiFi};
				\node (esp) [startstop, right of=serial,xshift=3cm,text width=4.5cm] {ESP8266};
				\node (deserialize) [process, right of=esp,xshift=3cm,text width=4cm] {UART};
				\node (arduino) [startstop, above of=deserialize,yshift=0.5cm, text width=4cm] {Arduino};
				
				\draw [latex-latex,thick] (pc) -- (serial) node [midway, left] (TextNode) {};
				\draw [latex-latex,thick] (serial) -- (esp) node [midway, left] (TextNode) {};
				\draw [latex-latex,thick] (esp) -- (deserialize) node [midway, left] (TextNode) {};
				\draw [latex-latex,thick] (deserialize) -- (arduino) node [midway, left] (TextNode) {}; 
				\draw [dashed,thick] (arduino.west) to[bend left=20] node[midway, above,yshift=0.5cm, anchor=center] (TextNode) {ROS communication}  (pc.east);
				\end{pgfonlayer}
\begin{pgfonlayer}{background}
				\node (kd) [draw=blue, fit=(pc) (serial) (esp), inner sep=0.15	cm, inner ysep=0.5cm, yshift=-0.3cm, xshift=-1.375cm, inner xsep=-1cm, dashed, thick, fill=blue!10, fill opacity=0.2] {};
				\node [yshift=2ex, blue] at (kd.south) {TCP/IP communication};
				
				\node (kd) [draw=red, fit=(deserialize) (arduino) (esp), inner sep=0.15cm, inner ysep=0.5cm, yshift=-0.3cm, xshift=1.375cm, inner xsep=-1cm, dashed,  thick, fill=red!10, fill opacity=0.2] {};
				\node [yshift=2ex, red] at (kd.south) {Serial communication};
\end{pgfonlayer}
			\end{tikzpicture}
		}
		\captionof{figure}{System view of communication}\label{tikz:communicationschema}
	\end{figure}


\subsection{Controller node}
The node used to steer the robot was developed by Husqvarna for their lawn mower \emph{Auto Mower 320} and used for research at Ã–rebro University. This node fulfilled the requirements that was needed for this project. It is a Python script that reads from the keyboard and publishes a \texttt{geometry\_msgs::Twist} message on the ROS bus. The message uses \texttt{linear.x} for forward speed and \texttt{angular.z} for angular speed.
\label{subsec:cn}


\subsection{Passthrough node}
\label{subsec:ptn}
The WiFi node is also very simple. During startup it connects to a dedicated WiFi router, and then connects to a hard-coded server IP. In the main \texttt{loop} function it reads from the serial and writes to the WiFi; as well as from the WiFi to the serial as was shown in fig. \vref{tikz:communicationschema}. To make it more reliable the node checks both network and server connection each iteration, and attempts to reconnect if any issues are detected. \par

\subsection{Arduino node}
\label{subsec:dd}
This node has two PID controllers with their own $\di{K}{P}$, $\di{K}{I}$ and $\di{K}{D}$  values, to set the velocity of the two wheels. It is necessary to have two PID controllers since the motors appear to have slightly different performance.\par

On major problem when implementing PID controllers to control the electrical motors is the deadband of the motors. The output from the controller is 0-4096 and between 0-700 nothing happens. To solve this; if the output is between 0-10 the output is set to 0, and if the output is between 11-700 the output is set to 700, else the output is clamped to be in between 700-4096.\par

The input signal from the encoders is smoothed with a 330ms sliding window, that means to get a velocity change to be fully visible it takes around 330 ms. This also means there is a delay that the PID controller doesn't know about, and it will therefore output a value without getting a signal back that something happens. This would cause the controller to increase it's output, and in this way it will overshoot by a large margin. To counteract this, a fraction of the output is fed back into the input as a promised velocity that will happen, so the controller will not ramp up to high output and therefore not overshoot.\par

For the communication with ESP8266 the Serial1 (\texttt{TX1,RX1}) is used instead of the usual Serial/USB (\texttt{TX0,RX0}). With this setup it is still possible to send debug data to the Arduino IDE.\par

This node subscribes to \texttt{/robot\_0/velocity\_commands} (\texttt{geometry\_msgs::Twist}) to get the commands. It advertises its pose on \texttt{/robot\_0/odometry} (\texttt{geometry\_msgs::Pose2D}).

\section{Results}

\begin{tabular}[]
  
\end{tabular}
Expected
\subsection{PID tuning}
\label{subsec:pidt}

\subsection{Odometry accuracy}

\bibliography{references.bib}
\end{document}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
